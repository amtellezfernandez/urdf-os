<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SO100 VLA Demo</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #111;
        color: #f5f5f5;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      header {
        padding: 0.75rem 1rem;
        background: #181818;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      header h1 {
        font-size: 1.1rem;
        margin: 0;
      }
      #phase-indicator {
        font-size: 0.9rem;
        padding: 0.15rem 0.5rem;
        border-radius: 999px;
        background: #333;
      }
      main {
        flex: 1;
        display: grid;
        grid-template-columns: 1.6fr 1fr;
        gap: 0.5rem;
        padding: 0.5rem;
        min-height: 0;
      }
      section {
        background: #181818;
        border-radius: 6px;
        border: 1px solid #333;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      section h2 {
        font-size: 0.95rem;
        margin: 0;
        padding: 0.5rem 0.75rem;
        border-bottom: 1px solid #333;
      }
      #video-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
        padding: 0.5rem;
      }
      #camera-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 0.5rem;
        width: 100%;
        height: 100%;
      }
      .camera-panel {
        display: flex;
        flex-direction: column;
        background: #222;
        border-radius: 4px;
        overflow: hidden;
      }
      .camera-label {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        color: #9aa0a6;
        border-bottom: 1px solid #333;
        text-transform: capitalize;
      }
      .camera-feed {
        width: 100%;
        height: auto;
        object-fit: contain;
        background: #000;
      }
      #video {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
      }
      #controls {
        padding: 0.5rem 0.75rem;
        border-top: 1px solid #333;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }
      button {
        background: #2d6cdf;
        border: none;
        color: #fff;
        padding: 0.25rem 0.7rem;
        border-radius: 4px;
        font-size: 0.85rem;
        cursor: pointer;
      }
      button.secondary {
        background: #333;
      }
      button:disabled {
        background: #333;
        cursor: default;
        opacity: 0.7;
      }
      #status-bar {
        font-size: 0.8rem;
        padding: 0.3rem 0.75rem;
        border-top: 1px solid #333;
        background: #141414;
      }
      #chat-log,
      #reasoning-log {
        flex: 1;
        padding: 0.5rem 0.75rem;
        overflow-y: auto;
        font-size: 0.85rem;
      }
      .log-entry {
        margin-bottom: 0.35rem;
      }
      .log-entry span.role {
        font-weight: 600;
        margin-right: 0.35rem;
      }
      .log-entry.system {
        color: #9aa0a6;
      }
      .log-entry.assistant {
        color: #a5d6ff;
      }
      .log-entry.user {
        color: #e8eaed;
      }
      #chat-input-row {
        display: flex;
        padding: 0.4rem 0.75rem 0.6rem;
        gap: 0.4rem;
        border-top: 1px solid #333;
      }
      #chat-input {
        flex: 1;
        background: #111;
        border-radius: 4px;
        border: 1px solid #333;
        padding: 0.25rem 0.5rem;
        color: inherit;
        font-size: 0.85rem;
      }
      #chat-input:focus {
        outline: none;
        border-color: #2d6cdf;
      }
      #right-column {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        min-height: 0;
      }
      #teleop-section {
        flex: 1;
      }
      #teleop-form {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.35rem 0.5rem;
        padding: 0.6rem 0.75rem 0.4rem;
        font-size: 0.85rem;
      }
      #teleop-form label {
        display: block;
        margin-bottom: 0.15rem;
        color: #c6cbd3;
      }
      #teleop-form select,
      #teleop-form input {
        width: 100%;
        background: #111;
        border: 1px solid #333;
        border-radius: 4px;
        color: #f5f5f5;
        padding: 0.35rem 0.45rem;
      }
      #teleop-form input:focus,
      #teleop-form select:focus {
        outline: none;
        border-color: #2d6cdf;
      }
      #teleop-actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.2rem 0.75rem 0.65rem;
        border-top: 1px solid #333;
      }
      #teleop-status {
        font-size: 0.85rem;
        color: #c6cbd3;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8rem;
        margin-top: 0.35rem;
      }
      th,
      td {
        text-align: left;
        padding: 0.25rem 0.4rem;
      }
      th {
        color: #c6cbd3;
        font-weight: 600;
        border-bottom: 1px solid #333;
      }
      td {
        border-bottom: 1px solid #222;
      }
      .muted {
        color: #9aa0a6;
      }
      footer {
        padding: 0.3rem 0.75rem;
        font-size: 0.75rem;
        border-top: 1px solid #333;
        background: #141414;
        color: #9aa0a6;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>SO100 VLA Demo</h1>
      <div id="phase-indicator">Idle</div>
    </header>

    <main>
      <section id="video-section">
        <h2>Cameras</h2>
        <div id="video-container">
          <div id="camera-grid">
            <!-- Camera panels will be dynamically created -->
          </div>
        </div>
        <div id="controls">
          <button id="connect-btn">Connect</button>
          <button id="disconnect-btn" disabled>Disconnect</button>
          <button id="start-stream-btn" disabled>Start Stream</button>
          <button id="stop-stream-btn" disabled class="secondary">
            Stop Stream
          </button>
        </div>
        <div id="status-bar">
          Status: <span id="status-text">Disconnected</span>
        </div>
      </section>

      <div id="right-column">
        <section id="chat-section">
          <h2>Chat & Reasoning</h2>
          <div id="chat-log"></div>
          <div id="reasoning-log"></div>
          <div id="chat-input-row">
            <input
              id="chat-input"
              type="text"
              placeholder="Chat (try: /stream on, /stream off, /help)"
            />
            <button id="send-chat-btn" disabled>Send</button>
          </div>
        </section>

        <section id="teleop-section">
          <h2>Teleop Control</h2>
          <div id="teleop-form">
            <div>
              <label for="teleop-id-select">Leader arm id</label>
              <select id="teleop-id-select"></select>
            </div>
            <div>
              <label for="teleop-port-input">Leader port</label>
              <input id="teleop-port-input" placeholder="/dev/ttyACM1" />
            </div>
            <div>
              <label for="robot-id-select">Follower arm id</label>
              <select id="robot-id-select"></select>
            </div>
            <div>
              <label for="robot-port-input">Follower port</label>
              <input id="robot-port-input" placeholder="/dev/ttyACM0" />
            </div>
          </div>
          <div id="teleop-actions">
            <button id="save-ports-btn">Save Ports</button>
            <button id="start-teleop-btn">Start Teleop</button>
            <button id="stop-teleop-btn" class="secondary" disabled>
              Stop
            </button>
            <div id="teleop-status" class="muted">Idle</div>
          </div>
          <div style="padding: 0 0.75rem 0.65rem">
            <div class="muted" style="font-size: 0.82rem">
              Calibration files detected under <code id="calib-root"></code>.
            </div>
            <div id="devices-table-wrapper"></div>
          </div>
        </section>
      </div>
    </main>

    <footer>
      SO100 VLA Demo (VLM stubbed by default). Use <code>USE_MOCK_ROBOT=true</code> for mock mode.
    </footer>

    <script>
      let ws = null;
      let isConnected = false;
      let deviceConfig = { devices: [], ports_file: "", calibration_root: "" };

      const connectBtn = document.getElementById("connect-btn");
      const disconnectBtn = document.getElementById("disconnect-btn");
      const startStreamBtn = document.getElementById("start-stream-btn");
      const stopStreamBtn = document.getElementById("stop-stream-btn");
      const sendChatBtn = document.getElementById("send-chat-btn");
      const chatInput = document.getElementById("chat-input");
      const cameraGrid = document.getElementById("camera-grid");
      const chatLog = document.getElementById("chat-log");

      // Track known cameras for dynamic panel creation
      const knownCameras = new Set();
      const reasoningLog = document.getElementById("reasoning-log");
      const statusText = document.getElementById("status-text");
      const phaseIndicator = document.getElementById("phase-indicator");
      const teleopIdSelect = document.getElementById("teleop-id-select");
      const teleopPortInput = document.getElementById("teleop-port-input");
      const robotIdSelect = document.getElementById("robot-id-select");
      const robotPortInput = document.getElementById("robot-port-input");
      const startTeleopBtn = document.getElementById("start-teleop-btn");
      const stopTeleopBtn = document.getElementById("stop-teleop-btn");
      const savePortsBtn = document.getElementById("save-ports-btn");
      const devicesTableWrapper = document.getElementById(
        "devices-table-wrapper"
      );
      const calibRootEl = document.getElementById("calib-root");
      const teleopStatusEl = document.getElementById("teleop-status");

      function setPhase(phase) {
        phaseIndicator.textContent = phase || "Idle";
      }

      function appendChat(role, text) {
        const div = document.createElement("div");
        div.classList.add("log-entry", role);
        const roleSpan = document.createElement("span");
        roleSpan.classList.add("role");
        roleSpan.textContent = role === "assistant" ? "Assistant" : "User";
        const textSpan = document.createElement("span");
        textSpan.textContent = text;
        div.appendChild(roleSpan);
        div.appendChild(textSpan);
        chatLog.appendChild(div);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      function appendReasoning(text) {
        const div = document.createElement("div");
        div.classList.add("log-entry", "system");
        div.textContent = text;
        reasoningLog.appendChild(div);
        reasoningLog.scrollTop = reasoningLog.scrollHeight;
      }

      function setConnectedUi(connected) {
        isConnected = connected;
        connectBtn.disabled = connected;
        disconnectBtn.disabled = !connected;
        startStreamBtn.disabled = !connected;
        stopStreamBtn.disabled = !connected;
        sendChatBtn.disabled = !connected;
        chatInput.disabled = !connected;
        statusText.textContent = connected ? "Connected" : "Disconnected";
        if (!connected) {
          setPhase("Idle");
        }
      }

      function renderDevicesTable() {
        if (!deviceConfig.devices.length) {
          devicesTableWrapper.innerHTML =
            '<div class="muted">No calibration files detected yet.</div>';
          return;
        }
        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        ["Role", "Type", "ID", "Port", "Calibration"].forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        deviceConfig.devices.forEach((d) => {
          const tr = document.createElement("tr");
          const cells = [
            d.role,
            d.type,
            d.id,
            d.port || "(unset)",
            d.calibration_path,
          ];
          cells.forEach((val) => {
            const td = document.createElement("td");
            td.textContent = val;
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        devicesTableWrapper.innerHTML = "";
        devicesTableWrapper.appendChild(table);
      }

      function fillDeviceSelects() {
        const teleops = deviceConfig.devices.filter((d) => d.role === "teleop");
        const robots = deviceConfig.devices.filter((d) => d.role === "robot");

        teleopIdSelect.innerHTML = "";
        robotIdSelect.innerHTML = "";

        teleops.forEach((d) => {
          const opt = document.createElement("option");
          opt.value = d.id;
          opt.textContent = `${d.id} (${d.type})`;
          teleopIdSelect.appendChild(opt);
        });

        robots.forEach((d) => {
          const opt = document.createElement("option");
          opt.value = d.id;
          opt.textContent = `${d.id} (${d.type})`;
          robotIdSelect.appendChild(opt);
        });

        if (teleops.length) {
          teleopIdSelect.value = teleops[0].id;
          teleopPortInput.value = teleops[0].port || "";
        }
        if (robots.length) {
          robotIdSelect.value = robots[0].id;
          robotPortInput.value = robots[0].port || "";
        }
      }

      async function refreshDeviceConfig() {
        try {
          const res = await fetch("/api/device-config");
          const data = await res.json();
          deviceConfig = data;
          calibRootEl.textContent = deviceConfig.calibration_root || "";
          renderDevicesTable();
          fillDeviceSelects();
        } catch (err) {
          console.error(err);
          appendReasoning("Could not load device config from backend.");
        }
      }

      function applyPortForSelection(role) {
        const targetId =
          role === "teleop" ? teleopIdSelect.value : robotIdSelect.value;
        const match = deviceConfig.devices.find(
          (d) => d.role === role && d.id === targetId
        );
        if (role === "teleop") {
          teleopPortInput.value = match?.port || "";
        } else {
          robotPortInput.value = match?.port || "";
        }
      }

      async function savePorts() {
        const payloads = [
          {
            role: "teleop",
            type: "so100_leader",
            id: teleopIdSelect.value,
            port: teleopPortInput.value.trim(),
          },
          {
            role: "robot",
            type: "so100_follower",
            id: robotIdSelect.value,
            port: robotPortInput.value.trim(),
          },
        ];
        try {
          for (const body of payloads) {
            if (!body.id || !body.port) continue;
            await fetch("/api/device-config", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            });
          }
          appendReasoning("Saved ports to device store.");
          await refreshDeviceConfig();
        } catch (err) {
          console.error(err);
          appendReasoning("Failed to save ports.");
        }
      }

      async function updateTeleopStatus() {
        try {
          const res = await fetch("/api/teleop/status");
          const data = await res.json();
          const running = data.running;
          teleopStatusEl.textContent = running
            ? `Running (pid ${data.pid || "?"})`
            : "Idle";
          startTeleopBtn.disabled = running;
          stopTeleopBtn.disabled = !running;
        } catch {
          teleopStatusEl.textContent = "Idle";
        }
      }

      async function startTeleop() {
        const teleopId = teleopIdSelect.value;
        const robotId = robotIdSelect.value;
        const teleopPort = teleopPortInput.value.trim();
        const robotPort = robotPortInput.value.trim();
        if (!teleopId || !robotId) {
          appendReasoning("Select both leader and follower ids first.");
          return;
        }
        try {
          const res = await fetch("/api/teleop/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              teleop_id: teleopId,
              robot_id: robotId,
              teleop_port: teleopPort || null,
              robot_port: robotPort || null,
            }),
          });
          if (!res.ok) {
            const err = await res.json();
            appendReasoning(`Teleop start failed: ${err.detail || res.status}`);
          } else {
            appendReasoning("Teleop loop launched.");
          }
        } catch (err) {
          console.error(err);
          appendReasoning("Failed to start teleop loop.");
        }
        await updateTeleopStatus();
      }

      async function stopTeleop() {
        try {
          await fetch("/api/teleop/stop", { method: "POST" });
          appendReasoning("Teleop loop stopped.");
        } catch (err) {
          console.error(err);
          appendReasoning("Failed to stop teleop loop.");
        }
        await updateTeleopStatus();
      }

      function connectWs() {
        if (ws && isConnected) return;
        const proto = window.location.protocol === "https:" ? "wss" : "ws";
        const url = `${proto}://${window.location.host}/ws`;
        ws = new WebSocket(url);

        ws.onopen = () => {
          setConnectedUi(true);
          appendReasoning("WebSocket connected.");
          // Convenience: start streaming immediately so cameras are visible.
          sendJson({ type: "command", action: "start_stream" });
        };

        ws.onclose = () => {
          setConnectedUi(false);
          appendReasoning("WebSocket disconnected.");
        };

        ws.onerror = (ev) => {
          console.error("WebSocket error", ev);
        };

        ws.onmessage = (ev) => {
          try {
            const data = JSON.parse(ev.data);
            handleMessage(data);
          } catch {
            console.warn("Non-JSON message from server:", ev.data);
          }
        };
      }

      function ensureCameraPanel(camName) {
        if (knownCameras.has(camName)) {
          return document.getElementById(`video-${camName}`);
        }
        // Create new camera panel
        const panel = document.createElement("div");
        panel.classList.add("camera-panel");
        panel.id = `panel-${camName}`;

        const label = document.createElement("div");
        label.classList.add("camera-label");
        label.textContent = camName;

        const img = document.createElement("img");
        img.classList.add("camera-feed");
        img.id = `video-${camName}`;
        img.alt = `${camName} camera`;

        panel.appendChild(label);
        panel.appendChild(img);
        cameraGrid.appendChild(panel);
        knownCameras.add(camName);
        return img;
      }

      function handleMessage(msg) {
        const type = msg.type;
        if (type === "frame") {
          // Handle multi-camera frames
          if (msg.cameras) {
            for (const [camName, camData] of Object.entries(msg.cameras)) {
              const imgEl = ensureCameraPanel(camName);
              if (imgEl && camData.image_b64) {
                imgEl.src = `data:image/jpeg;base64,${camData.image_b64}`;
              }
            }
          }
          // Backward compatibility: single image_b64
          if (msg.image_b64 && !msg.cameras) {
            const imgEl = ensureCameraPanel("wrist");
            if (imgEl) {
              imgEl.src = `data:image/jpeg;base64,${msg.image_b64}`;
            }
          }
        } else if (type === "chat") {
          appendChat("assistant", msg.text || "");
        } else if (type === "status") {
          if (msg.phase) {
            setPhase(
              msg.phase.charAt(0).toUpperCase() + msg.phase.slice(1)
            );
          }
          if (msg.text) {
            appendReasoning(`[status] ${msg.text}`);
          }
        } else if (type === "reasoning") {
          if (msg.thought) {
            appendReasoning(msg.thought);
          }
        } else if (type === "error") {
          appendReasoning(`[error] ${msg.text || "Unknown error"}`);
        }
      }

      function sendJson(obj) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          appendReasoning("Cannot send message: WebSocket not open.");
          return;
        }
        ws.send(JSON.stringify(obj));
      }

      connectBtn.addEventListener("click", () => {
        connectWs();
      });

      disconnectBtn.addEventListener("click", () => {
        if (ws) {
          ws.close();
        }
      });

      startStreamBtn.addEventListener("click", () => {
        sendJson({ type: "command", action: "start_stream" });
      });

      stopStreamBtn.addEventListener("click", () => {
        sendJson({ type: "command", action: "stop_stream" });
      });

      sendChatBtn.addEventListener("click", () => {
        const text = chatInput.value.trim();
        if (!text) return;
        appendChat("user", text);
        chatInput.value = "";
        sendJson({ type: "chat", text });
      });

      chatInput.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" && !ev.shiftKey) {
          ev.preventDefault();
          sendChatBtn.click();
        }
      });

      teleopIdSelect.addEventListener("change", () => applyPortForSelection("teleop"));
      robotIdSelect.addEventListener("change", () => applyPortForSelection("robot"));
      savePortsBtn.addEventListener("click", savePorts);
      startTeleopBtn.addEventListener("click", startTeleop);
      stopTeleopBtn.addEventListener("click", stopTeleop);

      refreshDeviceConfig();
      updateTeleopStatus();
      setInterval(updateTeleopStatus, 4000);
    </script>
  </body>
  </html>
